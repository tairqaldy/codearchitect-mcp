/**
 * Formats a conversation into markdown format.
 */

import type { Message } from '../shared/types.js';

const VERSION = '0.1.7';

/**
 * Legacy format - kept for backward compatibility
 */
export function formatMarkdown(
  conversation: string | Message[],
  topic: string,
  format: 'plain' | 'messages' = 'plain'
): string {
  const date = new Date().toISOString();

  let conversationText: string;

  if (format === 'messages' && Array.isArray(conversation)) {
    conversationText = formatMessages(conversation);
  } else {
    conversationText =
      typeof conversation === 'string' ? conversation : JSON.stringify(conversation, null, 2);
  }

  return `# ${topic}

**Date:** ${date}
**Type:** AI Conversation Session

---

## Conversation

${conversationText}

---

*Generated by CodeArchitect MCP v${VERSION}*
`;
}

/**
 * Formats an array of messages into markdown.
 */
function formatMessages(messages: Message[]): string {
  return messages
    .map((msg) => {
      const role = msg.role || 'unknown';
      const content =
        typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content, null, 2);
      return `**${role.toUpperCase()}:**\n\n${content}`;
    })
    .join('\n\n---\n\n');
}

/**
 * Parses plain text conversation into messages array
 * Attempts to detect "User:" and "Assistant:" patterns
 */
function parsePlainTextToMessages(text: string): Message[] {
  const messages: Message[] = [];
  const lines = text.split('\n');
  let currentRole: string | null = null;
  let currentContent: string[] = [];

  for (const line of lines) {
    // Try to detect role markers
    const userMatch = line.match(/^(User|USER):\s*(.*)$/i);
    const assistantMatch = line.match(/^(Assistant|ASSISTANT|AI):\s*(.*)$/i);

    if (userMatch) {
      // Save previous message if exists
      if (currentRole && currentContent.length > 0) {
        messages.push({
          role: currentRole,
          content: currentContent.join('\n').trim(),
        });
      }
      currentRole = 'user';
      currentContent = userMatch[2] ? [userMatch[2]] : [];
    } else if (assistantMatch) {
      // Save previous message if exists
      if (currentRole && currentContent.length > 0) {
        messages.push({
          role: currentRole,
          content: currentContent.join('\n').trim(),
        });
      }
      currentRole = 'assistant';
      currentContent = assistantMatch[2] ? [assistantMatch[2]] : [];
    } else if (currentRole) {
      // Continue current message
      currentContent.push(line);
    }
  }

  // Save last message
  if (currentRole && currentContent.length > 0) {
    messages.push({
      role: currentRole,
      content: currentContent.join('\n').trim(),
    });
  }

  return messages.length > 0 ? messages : [{ role: 'user', content: text }];
}

/**
 * Normalizes conversation to messages array
 */
function normalizeToMessages(
  conversation: string | Message[],
  format: 'plain' | 'messages'
): Message[] {
  if (format === 'messages' && Array.isArray(conversation)) {
    return conversation.map((msg) => ({
      role: msg.role || 'unknown',
      content: typeof msg.content === 'string' ? msg.content : String(msg.content),
    }));
  }

  if (typeof conversation === 'string') {
    return parsePlainTextToMessages(conversation);
  }

  // Fallback: convert to messages
  return [{ role: 'user', content: JSON.stringify(conversation, null, 2) }];
}

/**
 * Generates a short summary (1-2 sentences) from conversation
 */
function generateShortSummary(messages: Message[], topic: string): string {
  if (messages.length === 0) {
    return `Conversation about ${topic}.`;
  }

  const firstUserMessage = messages.find((m) => m.role === 'user');
  if (firstUserMessage && typeof firstUserMessage.content === 'string') {
    const firstLine = firstUserMessage.content.split('\n')[0].substring(0, 150);
    return `Discussion about ${topic}. ${firstLine}${firstLine.length >= 150 ? '...' : ''}`;
  }

  return `Conversation about ${topic} with ${messages.length} message(s).`;
}

/**
 * Generates detailed summary with request/response pairs
 */
function generateDetailedSummary(messages: Message[]): string {
  if (messages.length === 0) {
    return 'No messages in conversation.';
  }

  const sections: string[] = [];
  let requestCounter = 1;
  let i = 0;

  while (i < messages.length) {
    const userMsg = messages[i];
    if (userMsg.role === 'user') {
      const userContent =
        typeof userMsg.content === 'string'
          ? userMsg.content.substring(0, 200)
          : String(userMsg.content).substring(0, 200);
      const userTitle = userContent.split('\n')[0].substring(0, 60) + (userContent.length > 60 ? '...' : '');

      sections.push(`### Request ${requestCounter}: ${userTitle}`);
      sections.push(`**User Prompt:**`);
      sections.push(typeof userMsg.content === 'string' ? userMsg.content : String(userMsg.content));

      // Find corresponding assistant response
      if (i + 1 < messages.length && messages[i + 1].role === 'assistant') {
        const assistantMsg = messages[i + 1];
        const assistantContent =
          typeof assistantMsg.content === 'string'
            ? assistantMsg.content
            : String(assistantMsg.content);

        sections.push(`**AI Response Summary:**`);
        // Extract key points from assistant response
        const summary = extractResponseSummary(assistantContent);
        sections.push(summary);

        sections.push(`**Key Points:**`);
        const keyPoints = extractKeyPoints(assistantContent);
        keyPoints.forEach((point) => sections.push(`- ${point}`));

        i += 2; // Skip both user and assistant
      } else {
        i += 1; // Only user message
      }

      sections.push('');
      requestCounter++;
    } else {
      i += 1;
    }
  }

  return sections.join('\n');
}

/**
 * Extracts summary from assistant response
 */
function extractResponseSummary(content: string): string {
  // Try to find summary patterns
  const lines = content.split('\n');
  const summaryLines: string[] = [];

  // Look for first paragraph or bullet points
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.length > 0 && !trimmed.startsWith('-') && !trimmed.startsWith('*')) {
      summaryLines.push(trimmed);
      if (summaryLines.length >= 3) break; // First 3 lines
    }
  }

  if (summaryLines.length > 0) {
    return summaryLines.join(' ').substring(0, 500) + (summaryLines.join(' ').length > 500 ? '...' : '');
  }

  return content.substring(0, 500) + (content.length > 500 ? '...' : '');
}

/**
 * Extracts key points from content
 */
function extractKeyPoints(content: string): string[] {
  const points: string[] = [];
  const lines = content.split('\n');

  // Look for bullet points
  for (const line of lines) {
    const trimmed = line.trim();
    if ((trimmed.startsWith('-') || trimmed.startsWith('*')) && trimmed.length > 2) {
      points.push(trimmed.substring(1).trim());
      if (points.length >= 5) break; // Max 5 key points
    }
  }

  // If no bullet points found, extract first sentences
  if (points.length === 0) {
    const sentences = content.split(/[.!?]+/).filter((s) => s.trim().length > 20);
    points.push(...sentences.slice(0, 3).map((s) => s.trim()));
  }

  return points.length > 0 ? points : ['Key information from the conversation'];
}

/**
 * Formats summary markdown file
 */
export function formatSummaryMarkdown(
  conversation: string | Message[],
  topic: string,
  format: 'plain' | 'messages',
  fullContextFilename: string
): string {
  const date = new Date().toISOString();
  const messages = normalizeToMessages(conversation, format);
  const shortSummary = generateShortSummary(messages, topic);
  const detailedSummary = generateDetailedSummary(messages);

  return `# ${topic}

**Date:** ${date}
**Type:** AI Conversation Session Summary
**Full Context:** [${fullContextFilename}](${fullContextFilename})
**Message Count:** ${messages.length}

---

## Short Summary

${shortSummary}

---

## Detailed Summary

${detailedSummary}

---

*Generated by CodeArchitect MCP v${VERSION}*
`;
}

/**
 * Formats full context markdown file with JSON + human-readable format
 */
export function formatFullContextMarkdown(
  conversation: string | Message[],
  topic: string,
  format: 'plain' | 'messages',
  summaryFilename: string
): string {
  const date = new Date().toISOString();
  const messages = normalizeToMessages(conversation, format);
  const humanReadable = formatMessages(messages);

  // Format messages as clean JSON (for TOON conversion)
  const jsonMessages = messages.map((msg) => ({
    role: msg.role,
    content: typeof msg.content === 'string' ? msg.content : String(msg.content),
  }));

  return `# ${topic} - Full Context

**Date:** ${date}
**Type:** AI Conversation Session - Full Context
**Summary:** [${summaryFilename}](${summaryFilename})
**Message Count:** ${messages.length}
**Format:** Structured JSON (optimized for TOON conversion)

---

## Full Conversation (JSON)

\`\`\`json
${JSON.stringify(jsonMessages, null, 2)}
\`\`\`

---

## Human-Readable Format

${humanReadable}

---

*Generated by CodeArchitect MCP v${VERSION}*
*Note: JSON format optimized for TOON conversion (~40% token reduction)*
`;
}

